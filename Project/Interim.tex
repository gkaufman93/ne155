\section*{Plans for Completion}
As of this moment, the input file will resemble that for MCNP. However, given the more limited geometry, the cell and surface definitions will obviously be adjusted. As such, the input file will start with a title, and the first line (it's still undecided if comments will be allowed) will determine the total width and height of the system, as well as the number of cells in both the x and y directions. This will determine the minimum and maximum x and y coordinates, with an input width and height of $w$ and $h$ respectively:
$$-\dfrac{w}{2} \leq x \leq \dfrac{w}{2}, \dfrac{-h}{2} \leq y \leq \dfrac{h}{2}.$$
This will also determine the cell widths and heights, or $\delta$ and $\epsilon$ respectively, by dividing the total width and height by their respective number of cells. This will set the overall grid for the system.
The lines following this input will be considered ``macrocells.'' Since it is an inherently rectangular system, all macrocells will likewise be rectangular in nature. As such, the lines will start with the cell number, followed by the material number, and then the minimum and maximum x and y coordinates. Overlaps of different materials will be considered combinations of their respective respective properties, while overlaps of the same material will simply be overwritten (i.e., it will combine the two regions).
The next set of inputs will be the materials. As Python will be the language used, the actual number of materials used will not need to be explicitly mentioned. Instead, lines giving material properties will start with the letter ``m'', followed by the material number (as per MCNP material definitions, the value of the diffusion coefficient $D$, and the macroscopic cross section $\Sigma_a$. These values will be added to a dictionary (hash map) in the code for easy retrieval.
Finally, the input will give the user the option to define a source, designating the definition with a line starting with ``S''. This source can be defined as a constant or a function for a given x and y range. For example, using the keyword ``COS_X'' will give a source cosine function in the $x$-direction, and constant along the $y$-direction. Combinations of such source keywords will define a product of terms. After the function has been defined, the user has the option to determine the range. This will take the form of four numbers following the function definitions; if fewer than four numbers follow, the remaining dimensions are assumed to encompass the maximum/minimum dimensions for the grid. It is undecided whether the user can define multiple sources, or if successive source definitions simply overwrite their predecessor.
As mentioned before, the code itself will take advantage of numerous mathematical packages, such as NumPy and SciPy, in order to carry out the computation described in the sections above with the information given. Python dictionaries will provide a quick and efficient means for checking cell boundaries as well as accessing material data. The algorithm may also take advantage of sub-functions and recursive methods in order to create the coefficient matrix. The code will be implemented as a command-line UNIX tool, again in the vein of MCNP, allowing the user to define the input file inline as well as certain options. For example, the user may wish to print the inputs in a different format. In this case, the user can invoke the flag `-p'. This will make use of Python packages such as optparse and Click to interface with the bash environment. The specifics of this functionality are tentative at the moment, however.
Finally, the code will produce an output file. The default format of the output file will be three columns: $x$-coordinate, $y$-coordinate, and flux for the cell. The code will also output average flux for macrocells, if requested. The user will also have the option to display the code in a CSV-type format: the first row will be comprised of $y$-coordinates, and the first row $x$-coordinates. The following values correspond to flux in the cell pertaining to the $(x,y)$ coordinate. This would allow the user to import the output file into a spreadsheet application, for facilitated data visualization and chart production. Depending on the limitations posed by PyPlot, the code may also give the user options to plot the data in a heat map.
In order to test this code, MCNP will be used as a benchmark. Simple geometries that our code can parse will be created in tandem with MCNP input decks, and flux tallies will be invoked in a mesh orientation. This will provide a comparison for our code and allow for adjustments.
